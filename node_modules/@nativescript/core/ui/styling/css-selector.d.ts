import { DataType as CSSWhatDataType } from 'css-what';
import '../../globals';
import * as ReworkCSS from '../../css';
export declare const MEDIA_QUERY_SEPARATOR = "&&";
/**
 * An interface describing the shape of a type on which the selectors may apply.
 * Note, the ui/core/view.View implements Node.
 */
export interface Node {
    parent?: Node;
    _modalParent?: Node;
    id?: string;
    nodeName?: string;
    cssType?: string;
    cssClasses?: Set<string>;
    cssPseudoClasses?: Set<string>;
    getChildIndex?(node: Node): number;
    getChildAt?(index: number): Node;
    getChildrenCount?(): number;
}
export interface Declaration {
    property: string;
    value: string;
}
export type ChangeMap<T extends Node> = Map<T, Changes>;
export interface Changes {
    attributes?: Set<string>;
    pseudoClasses?: Set<string>;
}
declare const enum Rarity {
    Invalid = 4,
    Id = 3,
    Class = 2,
    Type = 1,
    PseudoClass = 0,
    Attribute = 0,
    Universal = 0,
    Inline = 0
}
declare const enum PseudoClassSelectorList {
    Regular = 0,
    Forgiving = 1,
    Relative = 2
}
declare enum Combinator {
    'descendant' = " ",
    'child' = ">",
    'adjacent' = "+",
    'sibling' = "~",
    'parent' = "<",
    'column-combinator' = "||"
}
declare type AttributeTest = 'exists' | 'equals' | 'start' | 'end' | 'any' | 'element' | 'hyphen';
interface LookupSorter {
    sortById(id: string, sel: SelectorCore): any;
    sortByClass(cssClass: string, sel: SelectorCore): any;
    sortByType(cssType: string, sel: SelectorCore): any;
    sortAsUniversal(sel: SelectorCore): any;
}
export declare abstract class SelectorBase {
    /**
     * Dynamic selectors depend on attributes and pseudo classes.
     */
    dynamic: boolean;
    abstract match(node: Node): boolean;
    abstract mayMatch(node: Node): boolean;
    abstract trackChanges(node: Node, map: ChangeAccumulator): void;
}
export declare abstract class SelectorCore extends SelectorBase {
    pos: number;
    specificity: number;
    rarity: Rarity;
    combinator: Combinator;
    ruleset: RuleSet;
    /**
     * If the selector is static returns if it matches the node.
     * If the selector is dynamic returns if it may match the node, and accumulates any changes that may affect its state.
     */
    abstract accumulateChanges(node: Node, map: ChangeAccumulator): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare abstract class SimpleSelector extends SelectorCore {
    accumulateChanges(node: Node, map?: ChangeAccumulator): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
}
export declare class InvalidSelector extends SimpleSelector {
    e: Error;
    constructor(e: Error);
    toString(): string;
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class UniversalSelector extends SimpleSelector {
    toString(): string;
    match(node: Node): boolean;
}
export declare class IdSelector extends SimpleSelector {
    id: string;
    constructor(id: string);
    toString(): string;
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class TypeSelector extends SimpleSelector {
    cssType: string;
    constructor(cssType: string);
    toString(): string;
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class ClassSelector extends SimpleSelector {
    cssClass: string;
    constructor(cssClass: string);
    toString(): string;
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class AttributeSelector extends SimpleSelector {
    attribute: string;
    test: AttributeTest;
    value: string;
    ignoreCase: boolean;
    constructor(attribute: string, test: AttributeTest, value: string, ignoreCase: boolean);
    toString(): string;
    match(node: Node): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
}
export declare class PseudoClassSelector extends SimpleSelector {
    cssPseudoClass: string;
    constructor(cssPseudoClass: string);
    toString(): string;
    match(node: Node): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
}
export declare abstract class FunctionalPseudoClassSelector extends PseudoClassSelector {
    protected selectors: Array<SimpleSelector | SimpleSelectorSequence | ComplexSelector>;
    protected selectorListType?: PseudoClassSelectorList;
    constructor(cssPseudoClass: string, dataType: CSSWhatDataType);
    toString(): string;
    match(node: Node): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
}
export declare class NotFunctionalPseudoClassSelector extends FunctionalPseudoClassSelector {
    match(node: Node): boolean;
}
export declare class IsFunctionalPseudoClassSelector extends FunctionalPseudoClassSelector {
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class WhereFunctionalPseudoClassSelector extends FunctionalPseudoClassSelector {
    match(node: Node): boolean;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class SimpleSelectorSequence extends SimpleSelector {
    selectors: SimpleSelector[];
    private head;
    constructor(selectors: SimpleSelector[]);
    toString(): string;
    match(node: Node): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
}
export declare class ComplexSelector extends SelectorCore {
    selectors: SimpleSelector[];
    private groups;
    private last;
    constructor(selectors: SimpleSelector[]);
    toString(): string;
    match(node: Node): boolean;
    mayMatch(node: Node): boolean;
    trackChanges(node: Node, map: ChangeAccumulator): void;
    lookupSort(sorter: LookupSorter, base?: SelectorCore): void;
    accumulateChanges(node: Node, map?: ChangeAccumulator): boolean;
}
export declare namespace Selector {
    class ChildGroup extends SelectorBase {
        private selectors;
        constructor(selectors: SelectorBase[]);
        getMatchingNode(node: Node, strict: boolean): Node;
        match(node: Node): boolean;
        mayMatch(node: Node): boolean;
        trackChanges(node: Node, map: ChangeAccumulator): void;
    }
    class SiblingGroup extends SelectorBase {
        private selectors;
        constructor(selectors: SimpleSelector[]);
        match(node: Node): boolean;
        mayMatch(node: Node): boolean;
        trackChanges(node: Node, map: ChangeAccumulator): void;
    }
    interface Bound {
        left: Node;
        right: Node;
    }
}
export declare class RuleSet {
    selectors: SelectorCore[];
    declarations: Declaration[];
    mediaQueryString: string;
    tag?: string | number;
    scopedTag?: string;
    constructor(selectors: SelectorCore[], declarations: Declaration[]);
    toString(): string;
    lookupSort(sorter: LookupSorter): void;
}
export declare function fromAstNode(astRule: ReworkCSS.Rule): RuleSet;
export declare function createSelector(sel: string): SimpleSelector | SimpleSelectorSequence | ComplexSelector;
export declare function matchMediaQueryString(mediaQueryString: string, cachedQueries: string[]): boolean;
export declare abstract class SelectorScope<T extends Node> implements LookupSorter {
    private id;
    private class;
    private type;
    private universal;
    position: number;
    getSelectorCandidates(node: T): SelectorCore[];
    sortById(id: string, sel: SelectorCore): void;
    sortByClass(cssClass: string, sel: SelectorCore): void;
    sortByType(cssType: string, sel: SelectorCore): void;
    sortAsUniversal(sel: SelectorCore): void;
    private addToMap;
    private makeDocSelector;
}
export declare class MediaQuerySelectorScope<T extends Node> extends SelectorScope<T> {
    private _mediaQueryString;
    constructor(mediaQueryString: string);
    get mediaQueryString(): string;
}
export declare class StyleSheetSelectorScope<T extends Node> extends SelectorScope<T> {
    private mediaQuerySelectorScopes;
    constructor(rulesets: RuleSet[]);
    private createMediaQuerySelectorScope;
    private lookupRulesets;
    query(node: T): SelectorsMatch<T>;
}
interface ChangeAccumulator {
    addAttribute(node: Node, attribute: string): void;
    addPseudoClass(node: Node, pseudoClass: string): void;
}
export declare class SelectorsMatch<T extends Node> implements ChangeAccumulator {
    changeMap: ChangeMap<T>;
    selectors: SelectorCore[];
    addAttribute(node: T, attribute: string): void;
    addPseudoClass(node: T, pseudoClass: string): void;
    properties(node: T): Changes;
}
export declare const CSSHelper: {
    createSelector: typeof createSelector;
    SelectorCore: typeof SelectorCore;
    SimpleSelector: typeof SimpleSelector;
    InvalidSelector: typeof InvalidSelector;
    UniversalSelector: typeof UniversalSelector;
    TypeSelector: typeof TypeSelector;
    ClassSelector: typeof ClassSelector;
    AttributeSelector: typeof AttributeSelector;
    PseudoClassSelector: typeof PseudoClassSelector;
    SimpleSelectorSequence: typeof SimpleSelectorSequence;
    Selector: typeof Selector;
    RuleSet: typeof RuleSet;
    SelectorScope: typeof SelectorScope;
    MediaQuerySelectorScope: typeof MediaQuerySelectorScope;
    StyleSheetSelectorScope: typeof StyleSheetSelectorScope;
    fromAstNode: typeof fromAstNode;
    SelectorsMatch: typeof SelectorsMatch;
};
export {};
